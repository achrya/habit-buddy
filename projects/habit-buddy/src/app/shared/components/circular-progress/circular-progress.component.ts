import { Component, Input, OnInit, OnDestroy, ElementRef, ViewChild, signal, effect } from '@angular/core';
import { CommonModule } from '@angular/common';
import * as d3 from 'd3';

@Component({
  selector: 'app-circular-progress',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="circular-progress-container" [style.width.px]="size" [style.height.px]="size">
      <svg #svgElement [attr.width]="size" [attr.height]="size" class="circular-progress-svg">
        <!-- SVG content will be generated by D3 -->
      </svg>
      
      <!-- Center content overlay -->
      <div class="center-content">
        <div class="progress-icon">
          <ng-content select="[slot=icon]"></ng-content>
        </div>
        <div class="progress-value">{{ percentage }}%</div>
        <div class="progress-label">{{ label }}</div>
      </div>
    </div>
  `,
  styles: [`
    .circular-progress-container {
      position: relative;
      display: inline-block;
    }
    
    .circular-progress-svg {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .center-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
    }
    
    .progress-icon {
      margin-bottom: 4px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .progress-value {
      font-size: 24px;
      font-weight: bold;
      color: #6366f1;
      line-height: 1;
      margin-bottom: 2px;
    }
    
    .progress-label {
      font-size: 11px;
      color: #6b7280;
      font-weight: 500;
      line-height: 1;
    }
  `]
})
export class CircularProgressComponent implements OnInit, OnDestroy {
  @ViewChild('svgElement', { static: true }) svgElement!: ElementRef<SVGElement>;
  
  @Input() percentage: number = 0;
  @Input() size: number = 120;
  @Input() strokeWidth: number = 8;
  @Input() label: string = 'Level Progress';
  @Input() primaryColor: string = '#6366f1';
  @Input() secondaryColor: string = '#e5e7eb';
  @Input() tertiaryColor: string = '#f59e0b';
  @Input() activityData: Array<{date: string, status: string, tooltip: string}> = [];
  
  private svg: any;
  private percentageSignal = signal(0);
  
  constructor() {
    // React to percentage changes
    effect(() => {
      if (this.svg) {
        this.updateProgress(this.percentageSignal());
      }
    });
  }
  
  ngOnInit() {
    this.initializeChart();
    this.percentageSignal.set(this.percentage);
  }
  
  ngOnDestroy() {
    if (this.svg) {
      this.svg.selectAll('*').remove();
    }
  }
  
  private initializeChart() {
    const element = this.svgElement.nativeElement;
    const radius = (this.size - this.strokeWidth) / 2;
    const center = this.size / 2;
    
    this.svg = d3.select(element);
    
    // Clear any existing content
    this.svg.selectAll('*').remove();
    
    // Create the background circle (gray track)
    this.svg.append('circle')
      .attr('cx', center)
      .attr('cy', center)
      .attr('r', radius)
      .attr('fill', 'none')
      .attr('stroke', this.secondaryColor)
      .attr('stroke-width', this.strokeWidth)
      .attr('class', 'background-circle');
    
    // Progress circles will be created dynamically in updateProgress method
    
    this.updateProgress(this.percentage);
  }
  
  private updateProgress(percentage: number) {
    if (!this.svg) return;
    
    const radius = (this.size - this.strokeWidth) / 2;
    const center = this.size / 2;
    
    // Remove existing progress elements
    this.svg.selectAll('.progress-circle').remove();
    this.svg.selectAll('.secondary-progress-circle').remove();
    this.svg.selectAll('.progress-path').remove();
    this.svg.selectAll('.secondary-progress-path').remove();
    this.svg.selectAll('.activity-segment').remove();
    
    // If we have activity data, show segmented progress
    if (this.activityData && this.activityData.length > 0) {
      this.drawSegmentedProgress(percentage);
    } else {
      // Fallback to original progress display
      this.drawSimpleProgress(percentage);
    }
  }
  
  private drawSegmentedProgress(percentage: number) {
    const radius = (this.size - this.strokeWidth) / 2;
    const center = this.size / 2;
    const circumference = 2 * Math.PI * radius;
    
    // Use recent activity data (last 14 days) for segments
    const totalDays = this.activityData.length;
    const segmentLength = circumference / totalDays;
    
    this.activityData.forEach((day, index) => {
      const startAngle = (index / totalDays) * 2 * Math.PI - Math.PI / 2;
      const endAngle = ((index + 1) / totalDays) * 2 * Math.PI - Math.PI / 2;
      
      let color = this.secondaryColor; // Default gray
      
      switch (day.status) {
        case 'completed':
          color = '#22c55e'; // Green
          break;
        case 'break':
          color = '#f97316'; // Orange for streak breaks
          break;
        case 'today':
          color = this.primaryColor; // Blue
          break;
        case 'missed':
        default:
          color = '#d1d5db'; // Light gray
          break;
      }
      
      // Create path for this segment
      const x1 = center + radius * Math.cos(startAngle);
      const y1 = center + radius * Math.sin(startAngle);
      const x2 = center + radius * Math.cos(endAngle);
      const y2 = center + radius * Math.sin(endAngle);
      
      const largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;
      
      const pathData = [
        `M ${x1} ${y1}`,
        `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`
      ].join(' ');
      
      const segment = this.svg.append('path')
        .attr('d', pathData)
        .attr('stroke', color)
        .attr('stroke-width', this.strokeWidth)
        .attr('stroke-linecap', 'round')
        .attr('fill', 'none')
        .attr('class', 'activity-segment')
        .style('cursor', 'help');
      
      // Add tooltip
      segment.append('title').text(day.tooltip);
      
      // Add animation
      const pathLength = segment.node()?.getTotalLength() || 0;
      segment
        .attr('stroke-dasharray', pathLength)
        .attr('stroke-dashoffset', pathLength)
        .transition()
        .duration(1000)
        .delay(index * 50)
        .ease(d3.easeCircleOut)
        .attr('stroke-dashoffset', 0);
    });
  }
  
  private drawSimpleProgress(percentage: number) {
    const radius = (this.size - this.strokeWidth) / 2;
    const circumference = 2 * Math.PI * radius;
    const center = this.size / 2;
    
    // Primary progress (blue) - goes up to 65%
    const primaryProgress = Math.min(percentage, 65);
    
    // Secondary progress (orange) - shows the remaining part beyond 65%
    const secondaryProgress = Math.max(0, percentage - 65);
    
    // Update primary progress using stroke-dasharray (simpler approach)
    const primaryCircumference = 2 * Math.PI * radius;
    const primaryOffset = primaryCircumference - (primaryProgress / 100) * primaryCircumference;
    
    // Create or update primary progress circle
    let primaryCircle = this.svg.select('.progress-circle');
    if (primaryCircle.empty()) {
      primaryCircle = this.svg.append('circle')
        .attr('class', 'progress-circle')
        .attr('cx', center)
        .attr('cy', center)
        .attr('r', radius)
        .attr('fill', 'none')
        .attr('stroke', this.primaryColor)
        .attr('stroke-width', this.strokeWidth)
        .attr('stroke-linecap', 'round')
        .attr('transform', `rotate(-90 ${center} ${center})`)
        .attr('stroke-dasharray', primaryCircumference)
        .attr('stroke-dashoffset', primaryCircumference);
    }
    
    primaryCircle
      .transition()
      .duration(1000)
      .ease(d3.easeCircleOut)
      .attr('stroke-dashoffset', primaryOffset);
    
    // Update secondary progress circle (orange part)
    if (secondaryProgress > 0) {
      const secondaryCircumference = 2 * Math.PI * radius;
      const secondaryOffset = secondaryCircumference - (secondaryProgress / 100) * secondaryCircumference;
      
      let secondaryCircle = this.svg.select('.secondary-progress-circle');
      if (secondaryCircle.empty()) {
        secondaryCircle = this.svg.append('circle')
          .attr('class', 'secondary-progress-circle')
          .attr('cx', center)
          .attr('cy', center)
          .attr('r', radius)
          .attr('fill', 'none')
          .attr('stroke', this.tertiaryColor)
          .attr('stroke-width', this.strokeWidth)
          .attr('stroke-linecap', 'round')
          .attr('transform', `rotate(${(65/100) * 360 - 90} ${center} ${center})`)
          .attr('stroke-dasharray', secondaryCircumference)
          .attr('stroke-dashoffset', secondaryCircumference);
      }
      
      secondaryCircle
        .transition()
        .duration(1000)
        .delay(500)
        .ease(d3.easeCircleOut)
        .attr('stroke-dashoffset', secondaryOffset);
    } else {
      // Hide secondary circle if no secondary progress
      this.svg.select('.secondary-progress-circle').remove();
    }
    
    // Remove the old path elements if they exist
    this.svg.select('.progress-path').remove();
    this.svg.select('.secondary-progress-path').remove();
  }
  
  // Method to update percentage from parent component
  updatePercentage(newPercentage: number) {
    this.percentage = newPercentage;
    this.percentageSignal.set(newPercentage);
    this.updateProgress(newPercentage);
  }
  
}
